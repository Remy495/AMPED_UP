// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AMPEDUPNODES_AMPEDUPNODES_H_
#define FLATBUFFERS_GENERATED_AMPEDUPNODES_AMPEDUPNODES_H_

#include "flatbuffers/flatbuffers.h"

namespace AmpedUpNodes {

struct Connection;
struct ConnectionBuilder;

struct ConstantValueFloat;
struct ConstantValueFloatBuilder;

struct ConstantValueInt;
struct ConstantValueIntBuilder;

struct Input;
struct InputBuilder;

struct Node;
struct NodeBuilder;

struct OutputRange;
struct OutputRangeBuilder;

struct NodeGraph;
struct NodeGraphBuilder;

enum class InputValue : uint8_t {
  NONE = 0,
  Connection = 1,
  ConstantValueFloat = 2,
  ConstantValueInt = 3,
  MIN = NONE,
  MAX = ConstantValueInt
};

inline const InputValue (&EnumValuesInputValue())[4] {
  static const InputValue values[] = {
    InputValue::NONE,
    InputValue::Connection,
    InputValue::ConstantValueFloat,
    InputValue::ConstantValueInt
  };
  return values;
}

inline const char * const *EnumNamesInputValue() {
  static const char * const names[5] = {
    "NONE",
    "Connection",
    "ConstantValueFloat",
    "ConstantValueInt",
    nullptr
  };
  return names;
}

inline const char *EnumNameInputValue(InputValue e) {
  if (flatbuffers::IsOutRange(e, InputValue::NONE, InputValue::ConstantValueInt)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInputValue()[index];
}

template<typename T> struct InputValueTraits {
  static const InputValue enum_value = InputValue::NONE;
};

template<> struct InputValueTraits<AmpedUpNodes::Connection> {
  static const InputValue enum_value = InputValue::Connection;
};

template<> struct InputValueTraits<AmpedUpNodes::ConstantValueFloat> {
  static const InputValue enum_value = InputValue::ConstantValueFloat;
};

template<> struct InputValueTraits<AmpedUpNodes::ConstantValueInt> {
  static const InputValue enum_value = InputValue::ConstantValueInt;
};

bool VerifyInputValue(flatbuffers::Verifier &verifier, const void *obj, InputValue type);
bool VerifyInputValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class NodeType : uint8_t {
  GUITAR_SIGNAL = 0,
  EFFECTS_PEDAL = 1,
  SINE_WAVE = 2,
  SQUARE_WAVE = 3,
  MULTIPLY = 4,
  ADD = 5,
  AVERAGE = 6,
  REMAP_RANGE = 7,
  REVERSE = 8,
  KNOB_POSITIONS = 9,
  MIN = GUITAR_SIGNAL,
  MAX = KNOB_POSITIONS
};

inline const NodeType (&EnumValuesNodeType())[10] {
  static const NodeType values[] = {
    NodeType::GUITAR_SIGNAL,
    NodeType::EFFECTS_PEDAL,
    NodeType::SINE_WAVE,
    NodeType::SQUARE_WAVE,
    NodeType::MULTIPLY,
    NodeType::ADD,
    NodeType::AVERAGE,
    NodeType::REMAP_RANGE,
    NodeType::REVERSE,
    NodeType::KNOB_POSITIONS
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[11] = {
    "GUITAR_SIGNAL",
    "EFFECTS_PEDAL",
    "SINE_WAVE",
    "SQUARE_WAVE",
    "MULTIPLY",
    "ADD",
    "AVERAGE",
    "REMAP_RANGE",
    "REVERSE",
    "KNOB_POSITIONS",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (flatbuffers::IsOutRange(e, NodeType::GUITAR_SIGNAL, NodeType::KNOB_POSITIONS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

struct Connection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEINDEX = 4,
    VT_OUTPUTINDEX = 6
  };
  uint16_t nodeIndex() const {
    return GetField<uint16_t>(VT_NODEINDEX, 0);
  }
  uint8_t outputIndex() const {
    return GetField<uint8_t>(VT_OUTPUTINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_NODEINDEX) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUTINDEX) &&
           verifier.EndTable();
  }
};

struct ConnectionBuilder {
  typedef Connection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodeIndex(uint16_t nodeIndex) {
    fbb_.AddElement<uint16_t>(Connection::VT_NODEINDEX, nodeIndex, 0);
  }
  void add_outputIndex(uint8_t outputIndex) {
    fbb_.AddElement<uint8_t>(Connection::VT_OUTPUTINDEX, outputIndex, 0);
  }
  explicit ConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Connection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Connection>(end);
    return o;
  }
};

inline flatbuffers::Offset<Connection> CreateConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t nodeIndex = 0,
    uint8_t outputIndex = 0) {
  ConnectionBuilder builder_(_fbb);
  builder_.add_nodeIndex(nodeIndex);
  builder_.add_outputIndex(outputIndex);
  return builder_.Finish();
}

struct ConstantValueFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstantValueFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ConstantValueFloatBuilder {
  typedef ConstantValueFloat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(ConstantValueFloat::VT_VALUE, value, 0.0f);
  }
  explicit ConstantValueFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConstantValueFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstantValueFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstantValueFloat> CreateConstantValueFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  ConstantValueFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ConstantValueInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstantValueIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ConstantValueIntBuilder {
  typedef ConstantValueInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(ConstantValueInt::VT_VALUE, value, 0);
  }
  explicit ConstantValueIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConstantValueInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstantValueInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstantValueInt> CreateConstantValueInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  ConstantValueIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  AmpedUpNodes::InputValue value_type() const {
    return static_cast<AmpedUpNodes::InputValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const AmpedUpNodes::Connection *value_as_Connection() const {
    return value_type() == AmpedUpNodes::InputValue::Connection ? static_cast<const AmpedUpNodes::Connection *>(value()) : nullptr;
  }
  const AmpedUpNodes::ConstantValueFloat *value_as_ConstantValueFloat() const {
    return value_type() == AmpedUpNodes::InputValue::ConstantValueFloat ? static_cast<const AmpedUpNodes::ConstantValueFloat *>(value()) : nullptr;
  }
  const AmpedUpNodes::ConstantValueInt *value_as_ConstantValueInt() const {
    return value_type() == AmpedUpNodes::InputValue::ConstantValueInt ? static_cast<const AmpedUpNodes::ConstantValueInt *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyInputValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const AmpedUpNodes::Connection *Input::value_as<AmpedUpNodes::Connection>() const {
  return value_as_Connection();
}

template<> inline const AmpedUpNodes::ConstantValueFloat *Input::value_as<AmpedUpNodes::ConstantValueFloat>() const {
  return value_as_ConstantValueFloat();
}

template<> inline const AmpedUpNodes::ConstantValueInt *Input::value_as<AmpedUpNodes::ConstantValueInt>() const {
  return value_as_ConstantValueInt();
}

struct InputBuilder {
  typedef Input Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(AmpedUpNodes::InputValue value_type) {
    fbb_.AddElement<uint8_t>(Input::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Input::VT_VALUE, value);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    AmpedUpNodes::InputValue value_type = AmpedUpNodes::InputValue::NONE,
    flatbuffers::Offset<void> value = 0) {
  InputBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_INPUTS = 6
  };
  AmpedUpNodes::NodeType type() const {
    return static_cast<AmpedUpNodes::NodeType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::Input>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::Input>> *>(VT_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(AmpedUpNodes::NodeType type) {
    fbb_.AddElement<uint8_t>(Node::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::Input>>> inputs) {
    fbb_.AddOffset(Node::VT_INPUTS, inputs);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    AmpedUpNodes::NodeType type = AmpedUpNodes::NodeType::GUITAR_SIGNAL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::Input>>> inputs = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_inputs(inputs);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    AmpedUpNodes::NodeType type = AmpedUpNodes::NodeType::GUITAR_SIGNAL,
    const std::vector<flatbuffers::Offset<AmpedUpNodes::Input>> *inputs = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<AmpedUpNodes::Input>>(*inputs) : 0;
  return AmpedUpNodes::CreateNode(
      _fbb,
      type,
      inputs__);
}

struct OutputRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutputRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINIMUM = 4,
    VT_MAXIMUM = 6
  };
  float minimum() const {
    return GetField<float>(VT_MINIMUM, 0.0f);
  }
  float maximum() const {
    return GetField<float>(VT_MAXIMUM, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MINIMUM) &&
           VerifyField<float>(verifier, VT_MAXIMUM) &&
           verifier.EndTable();
  }
};

struct OutputRangeBuilder {
  typedef OutputRange Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minimum(float minimum) {
    fbb_.AddElement<float>(OutputRange::VT_MINIMUM, minimum, 0.0f);
  }
  void add_maximum(float maximum) {
    fbb_.AddElement<float>(OutputRange::VT_MAXIMUM, maximum, 0.0f);
  }
  explicit OutputRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OutputRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutputRange>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutputRange> CreateOutputRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    float minimum = 0.0f,
    float maximum = 0.0f) {
  OutputRangeBuilder builder_(_fbb);
  builder_.add_maximum(maximum);
  builder_.add_minimum(minimum);
  return builder_.Finish();
}

struct NodeGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODES = 4,
    VT_OUTPUTRANGES = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::Node>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::Node>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::OutputRange>> *outputRanges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::OutputRange>> *>(VT_OUTPUTRANGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_OUTPUTRANGES) &&
           verifier.VerifyVector(outputRanges()) &&
           verifier.VerifyVectorOfTables(outputRanges()) &&
           verifier.EndTable();
  }
};

struct NodeGraphBuilder {
  typedef NodeGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::Node>>> nodes) {
    fbb_.AddOffset(NodeGraph::VT_NODES, nodes);
  }
  void add_outputRanges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::OutputRange>>> outputRanges) {
    fbb_.AddOffset(NodeGraph::VT_OUTPUTRANGES, outputRanges);
  }
  explicit NodeGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NodeGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeGraph> CreateNodeGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::Node>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AmpedUpNodes::OutputRange>>> outputRanges = 0) {
  NodeGraphBuilder builder_(_fbb);
  builder_.add_outputRanges(outputRanges);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeGraph> CreateNodeGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AmpedUpNodes::Node>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<AmpedUpNodes::OutputRange>> *outputRanges = nullptr) {
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<AmpedUpNodes::Node>>(*nodes) : 0;
  auto outputRanges__ = outputRanges ? _fbb.CreateVector<flatbuffers::Offset<AmpedUpNodes::OutputRange>>(*outputRanges) : 0;
  return AmpedUpNodes::CreateNodeGraph(
      _fbb,
      nodes__,
      outputRanges__);
}

inline bool VerifyInputValue(flatbuffers::Verifier &verifier, const void *obj, InputValue type) {
  switch (type) {
    case InputValue::NONE: {
      return true;
    }
    case InputValue::Connection: {
      auto ptr = reinterpret_cast<const AmpedUpNodes::Connection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InputValue::ConstantValueFloat: {
      auto ptr = reinterpret_cast<const AmpedUpNodes::ConstantValueFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InputValue::ConstantValueInt: {
      auto ptr = reinterpret_cast<const AmpedUpNodes::ConstantValueInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInputValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInputValue(
        verifier,  values->Get(i), types->GetEnum<InputValue>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace AmpedUpNodes

#endif  // FLATBUFFERS_GENERATED_AMPEDUPNODES_AMPEDUPNODES_H_
